#!/bin/bash
SOURCE="$0"
source /usr/lib/elive-tools/functions 2>/dev/null || true
EL_REPORTS="1"
el_make_environment 2>/dev/null || true
. gettext.sh 2>/dev/null || true
TEXTDOMAIN="elive-ai"
export TEXTDOMAIN

# attempts to get an answer if something failed
attempts=0
attempts_max=5
# randomness value, default is 0.7, smaller amount is more correct answers and bigger value is more creative (but can lead to errors, value 2 is almost gargbage, like the AI being in drugs), this value can be reconfigured later
temperature="0.8"
model="text-davinci-003"

# debug
set -e

# useful variables / user data:
username="$( awk -v user="$USER" -v FS=":" '{if ($1 == user) print $5}' /etc/passwd )"
if echo -e "$username" | grep -qsiE "(^Elive|user)" ; then
    username="$USER"
fi


# is input from a pipe?
if [[ ! -t 0 ]] ; then
    is_stdin=1
    stdin_message="$( cat 2>&1 | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" )"
fi


# get the request definitions
source /usr/share/elive-ai/requests/requests

#
# wrappers to allow both GUI and CLI
#

message_title="$( printf "$( eval_gettext "Supra-Intelligent AI for Elive" )" "" )"

guitool="yad --on-top --image=robot --center --title='$message_title'"

el_error_wrapper(){
    if ((is_interactive)) && ! ((is_gui_wanted)) ; then
        el_error "$@"
    else
        el_error "$@"
        $guitool --error --text="$@"
    fi
}

# END wrappers



# Functions
result_show_compare(){
    local message answer
    message="$1"
    answer="$2"

    if ((is_interactive)) && ! ((is_gui_wanted)) ; then
        echo -e "" 1>&2
        wdiff -w "$(tput bold;tput setaf 1)-" -x "$(tput sgr0)" -y "$(tput bold;tput setaf 2)+" -z "$(tput sgr0)" <( printf "%s\n" "$message" ) <( printf "%s\n" "$answer" )
        echo -e "" 1>&2
    else
        if $guitool --question --text="$( eval_gettext "Do you want to visually view the differences?" )" ; then
            urxvt -hold -title "$( eval_gettext "Close the terminal when you have finished" )"  -e bash -c "wdiff -w \"\$(tput bold;tput setaf 1)-\" -x \"\$(tput sgr0)\" -y \"\$(tput bold;tput setaf 2)+\" -z \"\$(tput sgr0)\" <( printf \"%s\" \"$message\" ) <( printf \"%s\" \"$answer\" )"
            meld <( printf "%s\n" "$message" | sed -e 's|\.|.\n|g' -e 's|,|,\n|g' ) <( printf "%s\n" "$answer" | sed -e 's|\.|.\n|g' -e 's|,|,\n|g' )
            sleep 4
        fi
    fi
}

result_show_dialog_copy(){
    local answer
    answer="$1"

    #if false ; then
    if ((is_interactive)) && ! ((is_gui_wanted)) ; then
        printf "%s\n" "$answer"
    else
        #if printf "%s\n" "$answer" | $guitool --width=620 --height="450" --text-info --title="$message_title" --ok-label="$( eval_gettext "Copy" )" --cancel-label="$( eval_gettext "Done" )" ; then
        printf "%s\n" "$answer" | yad --on-top --image=robot \
            --width=600 --height=400 --center \
            --text-info --no-markup --wrap \
            --title="$message_title - $mode mode" \
            --button=gtk-close --button="$( eval_gettext "Speak" )!stock_volume:12" --button="$( eval_gettext "Conversate" )!chat":10 --button=gtk-copy:11  --escape-ok
        returned=$?
        case "$returned" in
            10)
                echo -e "$message_complete_g" | xclip -i -selection clipboard
                el_notify soft "gtk-dialog-info" "$( eval_gettext "Copied" )" "$( eval_gettext "You can paste the full request into the website in order to run the same request." )"
                web-launcher "https://chat.openai.com/chat"
                # wait some time before to exit from this tool because otherwise the copy-paste is lost
                is_wait_needed=1
                ;;
            11)
                # copy to clipboard
                echo -e "$answer" | xclip -i -selection clipboard
                is_wait_needed=1
                ;;
            12)
                # copy to clipboard
                echo -e "$answer" | el_speak_text -f
                ;;
            0|*)
                true
                ;;
        esac
    fi
}

result_show_notification(){
    local answer title
    title="$1"
    shift
    answer="$1"
    shift

    if ((is_interactive)) && ! ((is_gui_wanted)) ; then
        echo -e "$answer"
    else
        el_notify normal robot "$title" "$answer"
    fi
}

chatgpt_ask(){
    local message error_type
    message="$1"
    # save the message in a global variable:
    message_complete_g="$message"

    # escape quotation marks
    escaped_prompt=$(echo "$message" | sed 's/"/\\"/g')

    if ((is_interactive)) ; then
        el_debug "Full Request:\n$message_complete_g"
    fi

    # request to OpenAI API
    response="$( curl -m 60  https://api.openai.com/v1/completions \
        -sS \
        -H 'Content-Type: application/json' \
        -H "Authorization: Bearer $OPENAI_TOKEN" \
        -d '{
            "model": "'"$model"'",
            "prompt": "'"${escaped_prompt}"'",
            "max_tokens": 3500,
            "user": "'"$machine_id"'",
            "temperature": '$temperature'
        }' | jq --indent 2 --monochrome-output )"

    answer_g="$( echo "$response" | jq -r '.choices[].text' 2>/dev/null  )"
    finish_reason="$( echo "$response" | jq -r '.choices[].finish_reason' 2>/dev/null )"

    # try again
    if [[ -z "$answer_g" ]] ; then
        error_type="$( echo "$response" | jq -r '.error.type' 2>/dev/null )"
        if [[ "$error_type" == "requests" ]] || [[ "$error_type" == "server_error" ]] || [[ "$error_type" = "null" ]] || [[ -z "$answer_g" ]] ; then
            if [[ "$attempts" -ge $attempts_max ]] ; then
                el_error_wrapper "$( eval_gettext "Too many requests, please wait before trying again..." )"
                exit 1
            else
                attempts="$(( $attempts + 1 ))"
                el_debug "too many attempts, trying again ($attempts) ..."
                sleep 5
                sleep $attempts

                $FUNCNAME "$@"
                return $?
            fi
        else
            # unknown error, print
            el_error_wrapper "problem fetching results: $error_type"
            echo "$response" | jq --indent 2 --color-output 1>&2
            exit 1
        fi
    fi

    # unfinished?
    if [[ -n "$finish_reason" ]] && [[ "$finish_reason" != "stop" ]] ; then
        el_warning "finish_reason is not stop: $finish_reason"
        echo "$response" | jq --indent 2 --color-output 1>&2
    fi
    if [[ -n "$finish_reason" ]] && [[ "$finish_reason" = "length" ]] ; then
        answer_g="$( printf "%s\n...[more]...\n" "$answer_g" )"
    fi

    # debug
    if [[ "$EL_DEBUG" -ge 4 ]] ; then
        echo "$response" | jq --indent 2 --color-output 1>&2
    fi

    el_debug "Q: $message_original"
    el_debug "A: $answer_g"

    # fixes
    # delete the first line if contains no useful information
    if echo "$answer_g" | head -1 | grep -qsE "^A?( |,|\.|:|)\s*$" ; then
        answer_g="$( printf "%s\n" "$answer_g" | sed -e '1d' )"
    fi
    if echo "$answer_g" | head -1 | grep -qsE "^A?( |,|\.|:|)\s*$" ; then
        answer_g="$( printf "%s\n" "$answer_g" | sed -e '1d' )"
    fi
    # remove markdown code-block marks:
    if echo "$answer_g" | head -1 | grep -qsiE '^```\w*$' ; then
        answer_g="$( printf "%s\n" "$answer_g" | sed -e '1d' )"
    fi
    if echo "$answer_g" | tail -1 | grep -qsiE '^```$' ; then
        answer_g="$( printf "%s\n" "$answer_g" | sed -e '$d' )"
    fi
    # remove starting commas (or similar) in single-line sentences
    #if [[ "$( echo "$answer_g" | wc -l )" = 1 ]] ; then
        #answer_g="$( printf "%s\n" "$answer_g" | sed -e 's|^,||g' -e 's|^\.||g' -e 's|^ ||g' )"
    #fi
}

chatgpt_apikey_get(){
    local verifier result request_verification
    request_verification="please write this exact word and only this word in a single line, no caps: enlightenment"

    # get key from web and insert it
    $guitool --info --text="$( eval_gettext "In order to use this tool, you need to add an API key. We will open a web page where you can generate a new API key, then copy it and insert it in the next question." )"
    ( web-launcher https://beta.openai.com/account/api-keys & )
    sleep 10

    result="$( $guitool --entry --text="$( eval_gettext "Insert here your API key" )" )"

    if [[ -n "$result" ]] ; then
        verifier="$( OPENAI_TOKEN="$result" chatgpt_ask "$request_verification" )"
        if [[ "$verifier" = "enlightenment" ]] ; then
            conf_chatgpt_apikey="$result"
            export OPENAI_TOKEN="$conf_chatgpt_apikey"
            el_config_save "conf_chatgpt_apikey"
        else
            local message_failed_response
            message_failed_response="$( printf "$( eval_gettext "Failed verification response, AI answered '%s' and should have answered '%s'" )" "$verifier" "enlightenment" )"

            el_error_wrapper "$message_failed_response"
            exit 1
        fi
    else
        $guitool --error --text="$( eval_gettext "You need to insert an API key to use. Exiting..." )"
        exit 1
    fi
}

main(){
    # pre {{{
    local message

    # dependencies
    if ! [[ -e "/usr/lib/elive-tools/functions" ]] ; then
        echo -e "Dependency required: Install the package 'elive-tools' first" 1>&2
        exit 1
    fi
    if ! [[ -e "/etc/elive-version" ]] ; then
        if ! el_dependencies_check "jq|wdiff|curl|batcat|yad|cowsay" ; then
            el_dependencies_install "jq|wdiff|curl|batcat|yad|cowsay"
        fi
    fi

    if ! el_verify_internet 2>/dev/null ; then
        local message_no_internet
        message_no_internet="$( printf "$( eval_gettext "You need to have a connection to internet in order to use this feature." )" "" )"

        el_error_wrapper "$message_no_internet"
    fi

    # machine ID
    if grep -qsF "machine-id: " "/etc/elive-version" 2>/dev/null ; then
        machine_id="$( cat /etc/elive-version | grep "^machine-id: " | sed -e 's|^machine-id: ||g' | tail -1 )"
    else
        if ! el_flag check warning_no_elive_os ; then
            notify-send -e -t 14000 -i bomb "Warning" "This is not an Elive Linux system,\nfeatures may be limited, for example some visual elements."
            el_flag add warning_no_elive_os
        fi
        machine_id="dummy"
    fi
    machine_id="${machine_id}-${USER}"

    # }}}
    # Usage {{{
    if [[ -z "$1" ]] && ! ((is_stdin)) ; then
        if ((is_interactive)) ; then
            echo -e "Usage: $(basename $BASH_SOURCE) mode message"
            echo -e "  you an also use this tool as a pipe, like: echo 'hell0 wrold' | $(basename $0) corrector"
            echo -e "Modes:"
            echo -e "\nText modifiers:"
            echo -e "  translate:    translates from any language (even if mixed) to your local language used in your Elive system"
            echo -e "  translate-en: translate any text to english, with well formed sentences and good and elegant english"
            echo -e "  corrector:    it corrects any given text (in any language)"
            echo -e "  proofread:    it corrects and improves slightly any given text"
            echo -e "  synonyms:     write synonyms for a given word, or define a concept. Ex: computer portable -> laptop"
            echo -e "  rephrase:     rewrites a text improving it"
            echo -e "  persuade:     rewrite a text in a more persuasive way"
            echo -e "  improver:     it rephrases texts in a more deeply, elegant and literary way, showing different options"
            echo -e "  summarize:    summarize a text, remove useless and unneeded parts"
            echo -e "  simplify:     simplify a text as much as possible, making it shorter and concise (lacking emotion)"
            echo -e "  organize:     rewrites your text in a list of points in a logical order"

            echo -e "\nTools:"
            echo -e "  explain:      explains a concept, a jargon, abbreviature, or anything!"
            echo -e "  ocrfix:       fixes the text of a wrongly detected characters from a scanned document"
            #echo -e "  code:         generates a source code from a well defined description, ex: in ruby, show the local weather"

            echo -e "\nCreative:"
            echo -e "  title:        suggests a good title for a specific purpose"
            echo -e "  titlepost:    suggest a good engaging (website) post title"
            echo -e "  intro:        writes an introductory text for an article or similar"
            echo -e "  story:        narrate a story based on my description"
            echo -e "  idea:         gives ides of how to continue a text"
            echo -e "  propose:      propose a text with more contents and ideas, like continuing it"
            echo -e "  expand:       expand a text with more and richer contents"
            echo -e "  product:      describe a product"
            echo -e "  seo:          creates a google-like result description to fill in your seo plugin"
            echo -e "  recipe:       creates a recipe based in your given ingredients"
            echo -e "  ux:           design an UX concept based in the described needs"
            echo -e "  techwriter:   write articles related with technology"
            echo -e "  domain:       give (web) domain name ideas"

            echo -e "\nSelf-Help:"
            echo -e "  therapist:    receive self-help about different topics related to mental"
            echo -e "  doctor:    receive self-help about different topics related to mental"
            echo -e "  inspirateme:  give me a personalized quote to inspire me"

            echo -e "\nFunny:"
            echo -e "  friend:       just like if you were talking to a friend"
            echo -e "  girlfriend:   your personal girlfriend (lol)"

            echo -e "\nWIP:"
            echo -e "  copywriter:   talk about something and with some selected options, you can develop specific-purpose beautiful texts"
            echo -e "  suggest-book: describe what type of book you want to read and it will give you a good suggestion"
            #echo -e "  psychologist:        "
            echo -e "  palette-mood:      generate a colorscheme based on your location's actual weather"
            echo -e "  smarter       answers with a scientific / philosofical / smart way"
            echo -e "  human-cyber-guidance / project-manager:  based on a specific goal, ask every day (or hour?) about the tasks reached / work done, in order to answer a guidance about how to go faster or suggest the next tasks to do (use a history.txt file where to put the previous answers in order to include all of them in a single shot, max 50 lines)"
            echo -e "  psico-historia?"
            #echo -e "  "
            #echo -e "  "
            #echo -e "  "
            #echo -e "  "
            #echo -e "  "
            echo -e "\nNotes: You can write in any language, and it will reply in the same one. The calls are a single shot, if you want to have a deeper conversation please use https://chat.openai.com/chat instead"
        else
            $guitool --error --text="$( eval_gettext "No requests given, use this tool as:\n" ) $SOURCE mode message"
        fi
        exit 1
    fi

    if [[ "$1" = "--gui" ]] ; then
        is_gui_wanted=1
        shift
    fi

    mode="$1"
    shift

    if ((is_stdin)) ; then
        message="$stdin_message"
    else
        message="$@"
    fi

    # replace newlines with its escaped code, otherwise it will not work
    message_original="$message"
    message="${message//$'\n'/\\n}"


    # }}}

    el_config_get
    if [[ -z "$conf_chatgpt_apikey" ]] ; then
        chatgpt_apikey_get
    fi

    # use key
    if [[ -n "$conf_chatgpt_apikey" ]] ; then
        export OPENAI_TOKEN="$conf_chatgpt_apikey"
    fi

    case "$mode" in
        "translate")
            chatgpt_ask "${request_translate_to_local}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "translate-en")
            chatgpt_ask "${request_translate_to_english_well}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "corrector"|"correct"|"correction")
            chatgpt_ask "${request_corrector}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "proofreader"|"proofreading"|"proofread")
            chatgpt_ask "${request_proofreader}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "synonyms"|"synonym")
            chatgpt_ask "${request_synonyms}\n\n${message}"
            answer_g="$( echo "$answer_g" | sort -u | sed -e '/^$/d' )"
            result_show_notification "$( eval_gettext "Synonyms / Definitions" )" "$answer_g"
            ;;
        "rephrase")
            chatgpt_ask "${request_rephrase}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "persuade")
            chatgpt_ask "${request_persuade}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "improver"|"improve")
            chatgpt_ask "${request_improver}\n\n${message}"
            # do not use when having more than 1 alrnative result:
            #result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "simplify")
            temperature="0.5"
            chatgpt_ask "${request_simplify}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "summarize")
            temperature="0.9"
            chatgpt_ask "${request_summarize}\n\n${message}"
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "organize")
            chatgpt_ask "${request_organize}\n\n${message}"
            #result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "propose")
            temperature="0.6"
            chatgpt_ask "${request_propose}\n\n${message}"
            # Prepend the word Idea before the idea / concept header:
            if echo "$answer_g" | head -1 | grep -qsiE "^( |,|\.)" ; then
                answer_g="$( printf "%s\n" "$answer_g" | sed -e 's|^, ||g' -e 's|^ ||g' -e "1s/^/$( eval_gettext "IDEA" ): /" -e '2s/^/\n/' )"
            fi
            result_show_dialog_copy "$answer_g"
            ;;
        "expand")
            temperature="0.5" # we need accurate information, so reduce randomness
            chatgpt_ask "${request_expand}\n\n${message}"
            # Prepend the word Idea before the idea / concept header:
            if echo "$answer_g" | head -1 | grep -qsiE "^( |,|\.)" ; then
                answer_g="$( printf "%s\n" "$answer_g" | sed -e 's|^, ||g' -e 's|^ ||g' -e "1s/^/$( eval_gettext "IDEA" ): /" -e '2s/^/\n/' )"
            fi
            result_show_dialog_copy "$answer_g"
            ;;
        "idea")
            temperature="0.5" # we need accurate information, so reduce randomness
            chatgpt_ask "${request_idea}\n\n${message}"
            # Prepend the word Idea before the idea / concept header:
            if echo "$answer_g" | head -1 | grep -qsiE "^( |,|\.)" ; then
                answer_g="$( printf "%s\n" "$answer_g" | sed -e 's|^, ||g' -e 's|^ ||g' -e "1s/^/$( eval_gettext "IDEA" ): /" -e '2s/^/\n/' )"
            fi
            result_show_dialog_copy "$answer_g"
            ;;
        "product")
            chatgpt_ask "${request_product} ${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "seo")
            temperature="1.0"
            if ! echo "$message" | grep -qs ".*#.*#" ; then
                el_error_wrapper "Your request must be used as 'company # keyword # description', for example:  elive # powerful # elive is a fast and beautiful OS"
                exit 1
            fi
            local company keyword description
            company="$( echo "$message" | awk -v FS="#" '{print $1}' )"
            read -r company <<< "$company"
            keyword="$( echo "$message" | awk -v FS="#" '{print $2}' )"
            read -r keyword <<< "$keyword"
            description="$( echo "$message" | awk -v FS="#" '{print $3}' )"
            read -r description <<< "$description"

            chatgpt_ask "${request_seo_googlewidget} Company Name: $company\nProduct/Service Description: $description\nKeyword: $keyword"

            result_show_dialog_copy "$answer_g"
            ;;
        "recipe")
            temperature="0.9"
            chatgpt_ask "${request_recipe} ${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "ux")
            temperature="0.5"
            chatgpt_ask "${request_ux}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "explain")
            temperature="0.5"
            chatgpt_ask "${request_explain}\n\n${message}"
            #result_show_notification "$( eval_gettext "Explanation:" )" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "ocrfix")
            temperature="0.6"
            chatgpt_ask "${request_ocrfix}\n\n${message}" | sed -e 's|^Correction:||g'
            result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "title")
            temperature="0.9"
            chatgpt_ask "${request_title}\n\n${message}"
            #result_show_compare "$message" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "titlepost")
            chatgpt_ask "${request_titlepost}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "intro")
            #temperature="0.6"
            chatgpt_ask "${request_intro}\n\n${message}"
            # Prepend the word Idea before the idea / concept header:
            if echo "$answer_g" | head -1 | grep -qsiE "^( |,|\.)" ; then
                answer_g="$( printf "%s\n" "$answer_g" | sed -e 's|^, ||g' -e 's|^ ||g' -e "1s/^/$( eval_gettext "IDEA" ): /" -e '2s/^/\n/' )"
            fi
            result_show_dialog_copy "$answer_g"
            ;;
        "story")
            chatgpt_ask "${request_storyteller}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "friend")
            temperature="0.9"
            chatgpt_ask "${request_friend}\n\n${message}"
            #result_show_notification "$( eval_gettext "Explanation:" )" "$answer_g"
            result_show_dialog_copy "$answer_g"
            ;;
        "therapist")
            chatgpt_ask "${request_therapist}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "doctor")
            temperature="0.5"
            chatgpt_ask "${request_doctor}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "inspirateme")
            chatgpt_ask "${request_inspirateme}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "techwriter")
            chatgpt_ask "${request_techwriter}\n\n${message}"
            result_show_dialog_copy "$answer_g"
            ;;
        "domain")
            temperature="0.6"
            chatgpt_ask "${request_domain}\n\n${message}"
            answer_g="$( echo "$answer_g" | sort -u | sed -e '/^$/d' )"
            result_show_dialog_copy "$answer_g"
            ;;
        "girlfriend")
            temperature="1.0"
            chatgpt_ask "${request_girlfriend}\n\n${message}"
            #result_show_notification "$( eval_gettext "Explanation:" )" "$answer_g"
            if ((is_interactive)) && ! ((is_gui_wanted)) && [[ -e "/usr/share/cowsay/cows/linda.cow" ]] ; then
                if ((is_console)) ; then
                    result_show_dialog_copy "$answer_g"
                else
                    result_show_dialog_copy "$answer_g" | cowsay -f linda
                fi
            else
                result_show_dialog_copy "$answer_g"
            fi
            ;;

        "code")
            # XXX NOTE: currently working but the results are not reliable, better to use chatgpt directly instead
            if ! echo "$message" | grep -qsiE "^In \w+" ; then
                el_error_wrapper "Your request must start by the language requested, for example: In ruby, how to calculate..."
                exit 1
            fi
            temperature="0.0"
            model="code-davinci-002"
            chatgpt_ask "\"\"\"\n${request_code}\n\n${message}\n\"\"\""
            #chatgpt_ask "\"\"\"\n${request_code} ${message}\n\"\"\""
            #chatgpt_ask "${request_code}\n\n${message}"
            if ((is_interactive)) && ! ((is_gui_wanted)) ; then
                lang="$( echo "$message" | cut -d" " -f2 | sed -E -e 's#(,|\.|:|;)\s*$##g' )"
                lang="${lang,,}"
                printf "%s\n" "$answer_g" | batcat -p --paging never --color always --language $lang
            else
                result_show_dialog_copy "$answer_g"
            fi
            ;;



        "test")
            #temperature="0.5"
            chatgpt_ask "${request_test}\n\n${message}"
            #result_show_dialog_copy "$answer_g"
            echo "$answer_g"
            ;;
        *)
            el_info "using free mode"
            chatgpt_ask "$mode $message"
            result_show_dialog_copy "$answer_g"
            ;;
    esac

    if ((is_wait_needed)) ; then
        el_debug "waiting a few seconds to not lose our copied text..."
        sleep 60
    fi

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
